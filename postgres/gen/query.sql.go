// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package postgres

import (
	"context"
)

const balanceGet = `-- name: BalanceGet :one
select cast(coalesce((select sum(w.sum) from withdrawal w where w.user_login = u.login),
                     0) as double precision) as withdrawn,
       u.accrual_balance                     as "current"
from "user" u
where u.login = $1
`

type BalanceGetRow struct {
	Withdrawn float64
	Current   float64
}

func (q *Queries) BalanceGet(ctx context.Context, login string) (*BalanceGetRow, error) {
	row := q.db.QueryRow(ctx, balanceGet, login)
	var i BalanceGetRow
	err := row.Scan(&i.Withdrawn, &i.Current)
	return &i, err
}

const orderGet = `-- name: OrderGet :one
select id, user_login, uploaded_at, accrual_status, accrual_points
from "order"
where id = $1
`

func (q *Queries) OrderGet(ctx context.Context, id string) (*Order, error) {
	row := q.db.QueryRow(ctx, orderGet, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.UserLogin,
		&i.UploadedAt,
		&i.AccrualStatus,
		&i.AccrualPoints,
	)
	return &i, err
}

const orderGetAll = `-- name: OrderGetAll :many
select id, user_login, uploaded_at, accrual_status, accrual_points
from "order"
where user_login = $1
`

func (q *Queries) OrderGetAll(ctx context.Context, userLogin string) ([]*Order, error) {
	rows, err := q.db.Query(ctx, orderGetAll, userLogin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserLogin,
			&i.UploadedAt,
			&i.AccrualStatus,
			&i.AccrualPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const orderGetWithNonFinalAccrualStatus = `-- name: OrderGetWithNonFinalAccrualStatus :many
select id, user_login, uploaded_at, accrual_status, accrual_points
from "order"
where accrual_status not in ('INVALID', 'PROCESSED')
limit $1
`

func (q *Queries) OrderGetWithNonFinalAccrualStatus(ctx context.Context, limit int32) ([]*Order, error) {
	rows, err := q.db.Query(ctx, orderGetWithNonFinalAccrualStatus, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserLogin,
			&i.UploadedAt,
			&i.AccrualStatus,
			&i.AccrualPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const orderSave = `-- name: OrderSave :exec
insert into "order" (id, user_login)
values ($1, $2)
`

func (q *Queries) OrderSave(ctx context.Context, iD string, userLogin string) error {
	_, err := q.db.Exec(ctx, orderSave, iD, userLogin)
	return err
}

const orderUpdateAccrualPoints = `-- name: OrderUpdateAccrualPoints :exec
update "order"
set accrual_points = $1
where id = $2
`

func (q *Queries) OrderUpdateAccrualPoints(ctx context.Context, accrualPoints *float64, iD string) error {
	_, err := q.db.Exec(ctx, orderUpdateAccrualPoints, accrualPoints, iD)
	return err
}

const orderUpdateAccrualStatus = `-- name: OrderUpdateAccrualStatus :exec
update "order"
set accrual_status = $1
where id = $2
`

func (q *Queries) OrderUpdateAccrualStatus(ctx context.Context, accrualStatus AccrualStatus, iD string) error {
	_, err := q.db.Exec(ctx, orderUpdateAccrualStatus, accrualStatus, iD)
	return err
}

const userAddAccrualBalance = `-- name: UserAddAccrualBalance :exec
update "user"
set accrual_balance = accrual_balance + $1
where login = $2
`

func (q *Queries) UserAddAccrualBalance(ctx context.Context, accrualBalance float64, login string) error {
	_, err := q.db.Exec(ctx, userAddAccrualBalance, accrualBalance, login)
	return err
}

const userExists = `-- name: UserExists :one
select exists (select 1 from "user" where login = $1)
`

func (q *Queries) UserExists(ctx context.Context, login string) (bool, error) {
	row := q.db.QueryRow(ctx, userExists, login)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userGet = `-- name: UserGet :one
select login, password, accrual_balance
from "user"
where login = $1
`

func (q *Queries) UserGet(ctx context.Context, login string) (*User, error) {
	row := q.db.QueryRow(ctx, userGet, login)
	var i User
	err := row.Scan(&i.Login, &i.Password, &i.AccrualBalance)
	return &i, err
}

const userGetForLoginAndPassword = `-- name: UserGetForLoginAndPassword :one
select login, password, accrual_balance
from "user"
where login = $1
  and password = $2
`

func (q *Queries) UserGetForLoginAndPassword(ctx context.Context, login string, password string) (*User, error) {
	row := q.db.QueryRow(ctx, userGetForLoginAndPassword, login, password)
	var i User
	err := row.Scan(&i.Login, &i.Password, &i.AccrualBalance)
	return &i, err
}

const userSave = `-- name: UserSave :exec
insert into "user" (login, password)
values ($1, $2)
`

func (q *Queries) UserSave(ctx context.Context, login string, password string) error {
	_, err := q.db.Exec(ctx, userSave, login, password)
	return err
}

const withdrawalGetAll = `-- name: WithdrawalGetAll :many
select w.id, w.order_number, w.user_login, w.sum, w.processed_at
from withdrawal w
         join "order" o on o.id = w.order_number
where o.user_login = $1
`

func (q *Queries) WithdrawalGetAll(ctx context.Context, userLogin string) ([]*Withdrawal, error) {
	rows, err := q.db.Query(ctx, withdrawalGetAll, userLogin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Withdrawal
	for rows.Next() {
		var i Withdrawal
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.UserLogin,
			&i.Sum,
			&i.ProcessedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const withdrawalSave = `-- name: WithdrawalSave :exec
insert into withdrawal (order_number, user_login, sum)
values ($1, $2, $3)
`

type WithdrawalSaveParams struct {
	OrderNumber string
	UserLogin   string
	Sum         float64
}

func (q *Queries) WithdrawalSave(ctx context.Context, arg WithdrawalSaveParams) error {
	_, err := q.db.Exec(ctx, withdrawalSave, arg.OrderNumber, arg.UserLogin, arg.Sum)
	return err
}
